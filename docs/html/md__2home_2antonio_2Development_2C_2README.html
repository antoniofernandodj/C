<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>learn the basics { </p><pre class="fragment">- basic syntax
- variables and data types
- constants (define, enum)
- operators (arithmetic, relational, logical, bitwise, etc.)
- conditionals (if, else, switch)
- loops (for, while, do-while)
- type casting (implicit, explicit)
- input/output (printf, scanf)
- functions (declaration, definition, calling)
- arrays (1D, 2D)
- pointers (basic usage, pointer arithmetic)
- structures (defining and using structs)
- memory management (malloc, free)
- typedef and #define
</pre><p> }</p>
<p>data types { </p><pre class="fragment">- primitive types (int, char, float, double, etc.)
- derived types (arrays, pointers, structures, unions)
- typedef
- enumerations (enum)
</pre><p> }</p>
<p>type casting { </p><pre class="fragment">- implicit casting
- explicit casting (type conversion)
- pointer type casting
</pre><p> }</p>
<p>input/output { </p><pre class="fragment">- standard input/output (stdio.h)
- file handling (fopen, fclose, fread, fwrite, fprintf, fscanf)
- command line arguments (argc, argv)
</pre><p> }</p>
<p>modules { </p><pre class="fragment">- standard library (stdlib.h, stdio.h, string.h, math.h, time.h, etc.)
- file handling (fopen, fread, fwrite, fclose, file pointers)
- process control (fork, exec, wait, exit)
- memory management (malloc, calloc, realloc, free)
- multithreading (pthread, mutex, condition variables)
- signal handling (signal, raise, sigaction)
- system calls (unistd.h, sys/types.h, sys/stat.h)

- custom (creating and using custom libraries, header files, modular code)
</pre><p> }</p>
<p>memory management { </p><pre class="fragment">- dynamic memory allocation (malloc, calloc, realloc, free)
- pointer arithmetic
- segmentation faults
- memory leaks
- dangling pointers
- buffer overflow
</pre><p> }</p>
<p>functions { </p><pre class="fragment">- defining functions
- function prototypes
- passing arguments (by value, by reference)
- recursion
- return values
- function pointers
- variable scope and lifetime (local, global, static variables)
- inline functions
- anonymous functions (using function pointers)
- function pointer as a decorator (modifying function behavior)
- using function pointers for iteration over arrays and structures
</pre><p> }</p>
<p>preprocessor { </p><pre class="fragment">- macros (#define)
- conditional compilation (#ifdef, #ifndef, #else, #endif)
- include guards
- file inclusion (#include)
- #pragma directives
</pre><p> }</p>
<p>error handling { </p><pre class="fragment">- errno
- assert
- custom error messages
- exit() and abort()
</pre><p> }</p>
<p>bit manipulation { </p><pre class="fragment">- bitwise operators (&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;)
- setting, clearing, toggling bits
- working with bit fields
</pre><p> }</p>
<p>pointers { </p><pre class="fragment">- pointer basics
- pointer arithmetic
- pointers to functions
- pointers to structures
- null pointers
- memory leaks
- dynamic memory management
</pre><p> }</p>
<p>paradigms { </p><pre class="fragment">- imperative programming (control flow, state changes)
- procedural programming (structured programming)
- functional programming (using function pointers and higher-order functions)
- object-oriented simulation in C (structs and function pointers)
</pre><p> }</p>
<p>OOP { </p><pre class="fragment">- structs and methods
- classes (simulating with structures)
- basic inheritance using composition
- inheritance (manually implementing inheritance via function pointers)
- function pointers (as a form of polymorphism)
- polymorphism (using function pointers for dynamic dispatch)
- encapsulation (hiding data via opaque pointers and interfaces)
- abstraction (simplifying complex systems with function pointers and structures)
- methods (managing methods within structures)
- dunder methods (simulating operator overloading in C)
</pre><p> }</p>
<p>data structures and algorithms { </p><pre class="fragment">- arrays (static and dynamic)
- linked lists (singly, doubly)
- stacks (implementation, usage)
- queues (implementation, usage)
- hash tables (open addressing, chaining)
- trees (binary trees, AVL trees, etc.)
- binary trees (binary search tree, balanced trees)
- heaps (min-heap, max-heap)
- sorting algorithms (bubble, insertion, selection, quicksort, mergesort)
- searching algorithms (linear search, binary search)
- graph algorithms (BFS, DFS, Dijkstraâ€™s algorithm)
- recursion (understanding recursion and tail recursion)
- divide and conquer approach
- dynamic programming (memoization, tabulation)
- time and space complexity (Big-O notation)
</pre><p> }</p>
<p>concurrency { </p><pre class="fragment">- multi-threading (pthread library)
- mutexes
- condition variables
- thread synchronization
- shared memory
</pre><p> }</p>
<p>learn a framework { </p><pre class="fragment">- GTK (creating graphical user interfaces)
- libcurl (HTTP client for networking)
- OpenGL, Vulkan (3D graphics and rendering)
- SDL2 (game development and multimedia)
- POSIX Threads (multi-threading and synchronization)
- ncurses (text-based user interfaces)
</pre><p> }</p>
<p>environment { </p><pre class="fragment">- building executables on different platforms (Windows, Linux, macOS)
- cross-compilation
- virtual machines (QEMU, Docker for C environments)
</pre><p> }</p>
<p>debugging { </p><pre class="fragment">- gdb (GNU Debugger)
- valgrind (memory leaks and memory management issues)
- logging (printf debugging, logging libraries)
</pre><p> }</p>
<p>optimization { </p><pre class="fragment">- code optimization techniques (loop unrolling, inlining, compiler optimizations)
- memory optimization (reducing memory usage)
</pre><p> }</p>
<p>testing { </p><pre class="fragment">- unit testing (using CUnit or CMocka)
- test-driven development (TDD with C)
- integration testing (testing modules together)
- mocking (creating mock functions for testing)
- memory management testing (using tools like Valgrind)
- fuzz testing (using libFuzzer)
</pre><p> }</p>
<p>version control { </p><pre class="fragment">- Git basics
- branching, merging
- commit messages and best practices
</pre><p> }</p>
<p>build systems { </p><pre class="fragment">- Makefiles
- CMake
- autoconf, automake
</pre><p> }</p>
<p>documentation { </p><pre class="fragment">- Doxygen for C
- inline documentation and comments
- creating API documentation
- man pages (creating manual pages for your C programs)
</pre><p> }</p>
<p>package managers { </p><pre class="fragment">- vcpkg
- pkg-config
- make
- CMake dependencies
</pre><p> }</p>
<p>static typing { </p><pre class="fragment">- static analysis tools (Splint, Coverity, Clang, GCC, etc.)
- linting tools (clang-tidy)
- inline assembly (integrating assembly code within C)
</pre><p> }</p>
<p>code formatting { </p><pre class="fragment">- clang-format (automatic code formatting)
- indent (code indentation tool)
- Linting (using `splint` for static analysis)
- GNU style vs BSD style (C coding conventions)
</pre><p> }</p>
<p>environment { </p><pre class="fragment">- IDEs (Visual Studio, Eclipse, Code::Blocks, etc.)
- terminal-based editors (vim, emacs)
- build automation tools (make, CMake, Ninja)
</pre><p> }</p>
<p>advanced debugging { </p><pre class="fragment">- gdb debugging commands (breakpoints, stepping, inspecting variables)
- performance profiling (gprof, perf)
</pre><p> }</p>
<p>advanced concepts { </p><pre class="fragment">- system programming {

    - understanding system calls and their role in interacting with the OS
    - working with low-level memory operations (using `mmap`, `brk`, `sbrk`, etc.)
    - process control (creating, terminating, and managing processes via `fork`, `exec`, `wait`, etc.)
    - memory management (manual memory allocation, using `malloc`, `calloc`, `free`, `realloc`)
    - working with file descriptors and I/O (low-level file operations, `open`, `read`, `write`, `close`)
    - buffer management (using `read`, `write` efficiently, managing large I/O buffers)
    - managing file locks and concurrency (file locks with `flock` or `fcntl` for ensuring access control)
    - optimizing system calls (minimizing overhead, using efficient system call strategies)

}

- operating system concepts {

    - file systems {

        - understanding file system architectures (ext4, NTFS, FAT32)
        - handling file I/O operations at the system level (using syscalls like `open`, `read`, `write`, `lseek`)
        - file system types and their use cases (block devices, network file systems, etc.)
        - mounting and unmounting file systems (using `mount`, `umount`)
        - virtual file systems (VFS) and their role in abstraction
        - permissions and ownership (managing file access control with `chmod`, `chown`)

    }

    - processes {

        - process states and life cycle (creation, scheduling, termination)
        - process scheduling algorithms (FCFS, SJF, Round-Robin, etc.)
        - handling zombie and orphan processes
        - managing background and foreground processes
        - process priorities and nice values (`nice`, `renice`)
        - process control block (PCB) and context switching

    }

    - memory management {

        - understanding paging, segmentation, and virtual memory
        - working with the heap and stack (understanding memory allocation behavior)
        - implementing and understanding memory pools
        - page faults and handling memory mapping (`mmap`)
        - handling segmentation faults and memory access violations
        - optimization of memory usage (minimizing fragmentation)

    }
}

- network programming {

    - working with sockets (TCP, UDP)
    - creating server-client applications (using `socket`, `bind`, `listen`, `accept`, `send`, `recv`)
    - handling multiple clients (using `select`, `poll`, or `epoll` for multiplexing)
    - socket programming with IPv4 and IPv6
    - understanding the transport layer (TCP vs UDP) and how to choose the correct protocol
    - working with raw sockets (direct access to network layer)
    - implementing protocols (HTTP, FTP, DNS) and understanding their stack implementations
    - network byte order conversion (`htonl`, `htons`, `ntohl`, `ntohs`)

}

- inter-process communication (IPC) {

    - using pipes (`pipe`, `mkfifo`) for unidirectional communication
    - message queues (using `msgget`, `msgsnd`, `msgrcv` for inter-process messaging)
    - shared memory (using `shmget`, `shmat`, `shmdt`, `shmctl` to share memory between processes)
    - semaphores (using `semget`, `semop`, `semctl` to control access to shared resources)
    - socket-based communication (IPC using sockets for inter-machine or network-based communication)
    - named pipes and FIFO for persistent communication
    - mutexes and condition variables for synchronization between processes

}

- signal handling {

    - handling Unix signals (`SIGINT`, `SIGTERM`, `SIGSEGV`, `SIGFPE`, etc.)
    - creating custom signal handlers with `signal()` and `sigaction()`
    - understanding signal masks and blocking signals during critical sections
    - managing signal delivery and process termination using signals
    - handling signals for inter-process communication
    - real-time signals and their use cases

}
</pre><p> }</p>
<p>advanced topics { </p><pre class="fragment">- kernel development basics {

    - understanding the architecture of an operating system kernel
    - writing simple kernel modules (using `init_module`, `cleanup_module`, and `insmod`)
    - working with kernel space vs user space
    - interacting with kernel APIs (working with system calls and kernel-level I/O)
    - kernel debugging and tracing (using `dmesg`, `gdb`, `kgdb`)
    - developing loadable kernel modules (LKM) for extending kernel functionality
    - kernel synchronization mechanisms (spinlocks, semaphores, tasklets)
    - understanding kernel boot process (GRUB, bootloader, kernel loading)

}

- embedded systems {

    - understanding embedded hardware platforms (ARM, AVR, MSP430, etc.)
    - programming embedded systems with low-level access to hardware
    - cross-compiling for embedded platforms using toolchains like GCC, Clang, etc.
    - working with embedded peripherals (GPIO, ADC, UART, SPI, I2C, etc.)
    - real-time operating systems (RTOS) and their usage in embedded systems (FreeRTOS, embOS, etc.)
    - debugging embedded systems (JTAG, SWD, gdb for embedded targets)
    - bootloaders and managing firmware updates (U-Boot, Barebox)
    - low-power embedded system design (sleep modes, energy-efficient hardware)

}

- cross-compilation {

    - setting up a cross-compilation toolchain (GCC, Clang, or custom toolchain for ARM, MIPS, etc.)
    - configuring `Makefile` for cross-compilation
    - cross-compiling C programs for embedded or foreign platforms
    - debugging and testing cross-compiled code (using simulators or hardware debuggers)
    - understanding target architecture and setting appropriate compilation flags
    - handling system-specific libraries and dependencies in cross-compilation

}

- low-level programming (bare-metal) {

    - programming without an operating system (bare-metal embedded development)
    - working directly with hardware registers and memory-mapped I/O
    - using interrupt vectors, setting up and handling interrupts
    - booting from raw hardware (implementing a bootloader)
    - creating simple I/O drivers (keyboard, display, sensors)
    - writing system initialization code (stack, heap, interrupt vector tables)
    - debugging low-level systems (using serial outputs, JTAG, and hardware debuggers)

}

- memory-mapped I/O {

    - understanding memory-mapped I/O (MMIO) and its importance in embedded systems
    - programming microcontroller registers directly for I/O control
    - using MMIO for communication with external peripherals (e.g., sensors, motors, ADCs)
    - mapping peripheral addresses to system memory (working with `volatile` keyword)
    - handling direct access to hardware in low-level embedded programming
    - performance considerations in memory-mapped I/O access patterns
    - DMA (Direct Memory Access) and its impact on memory-mapped I/O operations

}
</pre><p> } </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
